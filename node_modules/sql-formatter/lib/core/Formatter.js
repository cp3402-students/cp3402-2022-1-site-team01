"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _Indentation = _interopRequireDefault(require("./Indentation"));

var _InlineBlock = _interopRequireDefault(require("./InlineBlock"));

var _Params = _interopRequireDefault(require("./Params"));

var _utils = require("../utils");

var _token = require("./token");

var _formatCommaPositions = _interopRequireDefault(require("./formatCommaPositions"));

var _formatAliasPositions = _interopRequireDefault(require("./formatAliasPositions"));

var _tabularStyle = require("./tabularStyle");

var _AliasAs = _interopRequireDefault(require("./AliasAs"));

var _AsTokenFactory = _interopRequireDefault(require("./AsTokenFactory"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TABULAR_INDENT = ' '.repeat(10);
/** Main formatter class that produces a final output string from list of tokens */

var Formatter = /*#__PURE__*/function () {
  function Formatter(cfg) {
    _classCallCheck(this, Formatter);

    _defineProperty(this, "cfg", void 0);

    _defineProperty(this, "indentation", void 0);

    _defineProperty(this, "inlineBlock", void 0);

    _defineProperty(this, "aliasAs", void 0);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "asTokenFactory", void 0);

    _defineProperty(this, "currentNewline", true);

    _defineProperty(this, "previousReservedToken", _token.EOF_TOKEN);

    _defineProperty(this, "previousCommandToken", _token.EOF_TOKEN);

    _defineProperty(this, "tokens", []);

    _defineProperty(this, "index", -1);

    this.cfg = cfg;
    this.indentation = new _Indentation["default"](this.isTabularStyle() ? TABULAR_INDENT : this.cfg.indent);
    this.inlineBlock = new _InlineBlock["default"](this.cfg.expressionWidth);
    this.aliasAs = new _AliasAs["default"](this.cfg.aliasAs, this);
    this.params = new _Params["default"](this.cfg.params);
    this.asTokenFactory = new _AsTokenFactory["default"](this.cfg.keywordCase);
  }
  /**
   * SQL Tokenizer for this formatter, provided by subclasses.
   */


  _createClass(Formatter, [{
    key: "tokenizer",
    value: function tokenizer() {
      throw new Error('tokenizer() not implemented by subclass');
    }
    /**
     * Reprocess and modify a token based on parsed context.
     * Subclasses can override this to modify tokens during formatting.
     * @param {Token} token - The token to modify
     * @return {Token} new token or the original
     */

  }, {
    key: "tokenOverride",
    value: function tokenOverride(token) {
      return token;
    }
    /**
     * Formats an SQL query.
     * @param {string} query - The SQL query string to be formatted
     * @return {string} The formatter query
     */

  }, {
    key: "format",
    value: function format(query) {
      this.tokens = this.tokenizer().tokenize(query);
      this.asTokenFactory = new _AsTokenFactory["default"](this.cfg.keywordCase, this.tokens);
      var formattedQuery = this.getFormattedQueryFromTokens();
      var finalQuery = this.postFormat(formattedQuery);
      return finalQuery.replace(/^\n*/, '').trimEnd();
    }
    /**
     * Does post-processing on the formatted query.
     */

  }, {
    key: "postFormat",
    value: function postFormat(query) {
      if (this.cfg.tabulateAlias) {
        query = (0, _formatAliasPositions["default"])(query);
      }

      if (this.cfg.commaPosition === 'before' || this.cfg.commaPosition === 'tabular') {
        query = (0, _formatCommaPositions["default"])(query, this.cfg);
      }

      return query;
    }
    /**
     * Performs main construction of query from token list, delegates to other methods for formatting based on token criteria
     */

  }, {
    key: "getFormattedQueryFromTokens",
    value: function getFormattedQueryFromTokens() {
      var formattedQuery = '';

      for (this.index = 0; this.index < this.tokens.length; this.index++) {
        var token = this.tokenOverride(this.tokens[this.index]); // if token is a Reserved Keyword, Command, Binary Command, Dependent Clause, Logical Operator

        if ((0, _token.isReserved)(token)) {
          this.previousReservedToken = token;

          if (token.type !== _token.TokenType.RESERVED_KEYWORD && token.type !== _token.TokenType.RESERVED_JOIN_CONDITION) {
            // convert Reserved Command or Logical Operator to tabular format if needed
            token = (0, _tabularStyle.toTabularToken)(token, this.cfg.indentStyle);
          }

          if (token.type === _token.TokenType.RESERVED_COMMAND) {
            this.previousCommandToken = token;
          }
        }

        if (token.type === _token.TokenType.LINE_COMMENT) {
          formattedQuery = this.formatLineComment(token, formattedQuery);
        } else if (token.type === _token.TokenType.BLOCK_COMMENT) {
          formattedQuery = this.formatBlockComment(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_COMMAND) {
          this.currentNewline = this.checkNewline(token);
          formattedQuery = this.formatCommand(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_BINARY_COMMAND) {
          formattedQuery = this.formatBinaryCommand(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_DEPENDENT_CLAUSE) {
          formattedQuery = this.formatDependentClause(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_JOIN_CONDITION) {
          formattedQuery = this.formatJoinCondition(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_LOGICAL_OPERATOR) {
          formattedQuery = this.formatLogicalOperator(token, formattedQuery);
        } else if (token.type === _token.TokenType.RESERVED_KEYWORD) {
          formattedQuery = this.formatKeyword(token, formattedQuery);
        } else if (token.type === _token.TokenType.BLOCK_START) {
          formattedQuery = this.formatBlockStart(token, formattedQuery);
        } else if (token.type === _token.TokenType.BLOCK_END) {
          formattedQuery = this.formatBlockEnd(token, formattedQuery);
        } else if (token.type === _token.TokenType.PLACEHOLDER) {
          formattedQuery = this.formatPlaceholder(token, formattedQuery);
        } else if (token.type === _token.TokenType.OPERATOR) {
          formattedQuery = this.formatOperator(token, formattedQuery);
        } else {
          formattedQuery = this.formatWord(token, formattedQuery);
        }
      }

      return (0, _tabularStyle.replaceTabularPlaceholders)(formattedQuery);
    }
    /**
     * Formats word tokens + any potential AS tokens for aliases
     */

  }, {
    key: "formatWord",
    value: function formatWord(token, query) {
      var finalQuery = query;

      if (this.aliasAs.shouldAddBefore(token)) {
        finalQuery = this.formatWithSpaces(this.asTokenFactory.token(), finalQuery);
      }

      finalQuery = this.formatWithSpaces(token, finalQuery);

      if (this.aliasAs.shouldAddAfter()) {
        finalQuery = this.formatWithSpaces(this.asTokenFactory.token(), finalQuery);
      }

      return finalQuery;
    }
    /**
     * Checks if a newline should currently be inserted
     */

  }, {
    key: "checkNewline",
    value: function checkNewline(token) {
      var nextTokens = this.tokensUntilNextCommandOrQueryEnd(); // auto break if SELECT includes CASE statements

      if (this.isWithinSelect() && nextTokens.some(_token.isToken.CASE)) {
        return true;
      }

      switch (this.cfg.multilineLists) {
        case 'always':
          return true;

        case 'avoid':
          return false;

        case 'expressionWidth':
          return this.inlineWidth(token, nextTokens) > this.cfg.expressionWidth;

        default:
          // multilineLists mode is a number
          return this.countClauses(nextTokens) > this.cfg.multilineLists || this.inlineWidth(token, nextTokens) > this.cfg.expressionWidth;
      }
    }
  }, {
    key: "inlineWidth",
    value: function inlineWidth(token, tokens) {
      var tokensString = tokens.map(function (_ref) {
        var value = _ref.value;
        return value === ',' ? value + ' ' : value;
      }).join('');
      return "".concat(token.whitespaceBefore).concat(token.value, " ").concat(tokensString).length;
    }
    /**
     * Counts comma-separated clauses (doesn't count commas inside blocks)
     * Note: There's always at least one clause.
     */

  }, {
    key: "countClauses",
    value: function countClauses(tokens) {
      var count = 1;
      var openBlocks = 0;

      var _iterator = _createForOfIteratorHelper(tokens),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              type = _step$value.type,
              value = _step$value.value;

          if (value === ',' && openBlocks === 0) {
            count++;
          }

          if (type === _token.TokenType.BLOCK_START) {
            openBlocks++;
          }

          if (type === _token.TokenType.BLOCK_END) {
            openBlocks--;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return count;
    }
    /** get all tokens between current token and next Reserved Command or query end */

  }, {
    key: "tokensUntilNextCommandOrQueryEnd",
    value: function tokensUntilNextCommandOrQueryEnd() {
      var tail = this.tokens.slice(this.index + 1);
      return tail.slice(0, tail.length ? tail.findIndex(function (token) {
        return (0, _token.isCommand)(token) || token.value === ';';
      }) : undefined);
    }
    /** Formats a line comment onto query */

  }, {
    key: "formatLineComment",
    value: function formatLineComment(token, query) {
      return this.addNewline(query + this.show(token));
    }
    /** Formats a block comment onto query */

  }, {
    key: "formatBlockComment",
    value: function formatBlockComment(token, query) {
      return this.addNewline(this.addNewline(query) + this.indentComment(token.value));
    }
    /** Aligns comment to current indentation level */

  }, {
    key: "indentComment",
    value: function indentComment(comment) {
      return comment.replace(/\n[\t ]*/g, '\n' + this.indentation.getIndent() + ' ');
    }
    /**
     * Formats a Reserved Command onto query, increasing indentation level where necessary
     */

  }, {
    key: "formatCommand",
    value: function formatCommand(token, query) {
      this.indentation.decreaseTopLevel();
      query = this.addNewline(query); // indent tabular formats, except when preceding a (

      if (this.isTabularStyle()) {
        if (this.tokenLookAhead().value !== '(') {
          this.indentation.increaseTopLevel();
        }
      } else {
        this.indentation.increaseTopLevel();
      }

      query += this.equalizeWhitespace(this.show(token)); // print token onto query

      if (this.currentNewline && !this.isTabularStyle()) {
        query = this.addNewline(query);
      } else {
        query += ' ';
      }

      return query;
    }
    /**
     * Formats a Reserved Binary Command onto query, joining neighbouring tokens
     */

  }, {
    key: "formatBinaryCommand",
    value: function formatBinaryCommand(token, query) {
      var isJoin = /JOIN/i.test(token.value); // check if token contains JOIN

      if (!isJoin || this.isTabularStyle()) {
        // decrease for boolean set operators or in tabular mode
        this.indentation.decreaseTopLevel();
      }

      query = this.addNewline(query) + this.equalizeWhitespace(this.show(token));
      return isJoin ? query + ' ' : this.addNewline(query);
    }
    /**
     * Formats a Reserved Keyword onto query, skipping AS if disabled
     */

  }, {
    key: "formatKeyword",
    value: function formatKeyword(token, query) {
      if (_token.isToken.AS(token) && this.aliasAs.shouldRemove()) {
        return query;
      }

      return this.formatWithSpaces(token, query);
    }
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     */

  }, {
    key: "formatDependentClause",
    value: function formatDependentClause(token, query) {
      return this.addNewline(query) + this.equalizeWhitespace(this.show(token)) + ' ';
    } // Formats ON and USING keywords

  }, {
    key: "formatJoinCondition",
    value: function formatJoinCondition(token, query) {
      return query + this.equalizeWhitespace(this.show(token)) + ' ';
    }
    /**
     * Formats an Operator onto query, following rules for specific characters
     */

  }, {
    key: "formatOperator",
    value: function formatOperator(token, query) {
      // special operator
      if (token.value === ',') {
        return this.formatComma(token, query);
      } else if (token.value === ';') {
        return this.formatQuerySeparator(token, query);
      } else if (['$', '['].includes(token.value)) {
        return this.formatWithSpaces(token, query, 'before');
      } else if ([':', ']'].includes(token.value)) {
        return this.formatWithSpaces(token, query, 'after');
      } else if (['.', '{', '}', '`'].includes(token.value)) {
        return this.formatWithoutSpaces(token, query);
      } // regular operator


      if (this.cfg.denseOperators && this.tokenLookBehind().type !== _token.TokenType.RESERVED_COMMAND) {
        // do not trim whitespace if SELECT *
        return this.formatWithoutSpaces(token, query);
      }

      return this.formatWithSpaces(token, query);
    }
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     */

  }, {
    key: "formatLogicalOperator",
    value: function formatLogicalOperator(token, query) {
      // ignore AND when BETWEEN x [AND] y
      if (_token.isToken.AND(token) && _token.isToken.BETWEEN(this.tokenLookBehind(2))) {
        return this.formatWithSpaces(token, query);
      }

      if (this.isTabularStyle()) {
        this.indentation.decreaseTopLevel();
      }

      if (this.cfg.logicalOperatorNewline === 'before') {
        return (this.currentNewline ? this.addNewline(query) : query) + this.equalizeWhitespace(this.show(token)) + ' ';
      } else {
        query += this.show(token);
        return this.currentNewline ? this.addNewline(query) : query;
      }
    }
    /** Replace any sequence of whitespace characters with single space */

  }, {
    key: "equalizeWhitespace",
    value: function equalizeWhitespace(string) {
      return string.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/g, ' ');
    }
    /**
     * Formats a Block Start token (left paren/bracket/brace, CASE) onto query, beginning an Inline Block or increasing indentation where necessary
     */

  }, {
    key: "formatBlockStart",
    value: function formatBlockStart(token, query) {
      if (_token.isToken.CASE(token)) {
        query = this.formatWithSpaces(token, query);
      } else {
        var _token$whitespaceBefo;

        // Take out the preceding space unless there was whitespace there in the original query
        // or another opening parens or line comment
        var preserveWhitespaceFor = [_token.TokenType.BLOCK_START, _token.TokenType.LINE_COMMENT, _token.TokenType.OPERATOR];

        if (((_token$whitespaceBefo = token.whitespaceBefore) === null || _token$whitespaceBefo === void 0 ? void 0 : _token$whitespaceBefo.length) === 0 && !preserveWhitespaceFor.includes(this.tokenLookBehind().type)) {
          query = (0, _utils.trimSpacesEnd)(query);
        } else if (!this.cfg.newlineBeforeOpenParen) {
          query = query.trimEnd() + ' ';
        }

        query += this.show(token);
        this.inlineBlock.beginIfPossible(this.tokens, this.index);
      }

      if (!this.inlineBlock.isActive()) {
        this.indentation.increaseBlockLevel();

        if (!_token.isToken.CASE(token) || this.cfg.multilineLists === 'always') {
          query = this.addNewline(query);
        }
      }

      return query;
    }
    /**
     * Formats a Block End token (right paren/bracket/brace, END) onto query, closing an Inline Block or decreasing indentation where necessary
     */

  }, {
    key: "formatBlockEnd",
    value: function formatBlockEnd(token, query) {
      if (this.inlineBlock.isActive()) {
        this.inlineBlock.end();

        if (_token.isToken.END(token)) {
          return this.formatWithSpaces(token, query); // add space before END when closing inline block
        }

        return this.formatWithSpaces(token, query, 'after'); // do not add space before )
      } else {
        this.indentation.decreaseBlockLevel();

        if (this.isTabularStyle()) {
          // +1 extra indentation step for the closing paren
          query = this.addNewline(query) + this.indentation.getSingleIndent();
        } else if (this.cfg.newlineBeforeCloseParen) {
          query = this.addNewline(query);
        } else {
          query = query.trimEnd() + ' ';
        }

        return this.formatWithSpaces(token, query);
      }
    }
    /**
     * Formats a Placeholder item onto query, to be replaced with the value of the placeholder
     */

  }, {
    key: "formatPlaceholder",
    value: function formatPlaceholder(token, query) {
      return query + this.params.get(token) + ' ';
    }
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     */

  }, {
    key: "formatComma",
    value: function formatComma(token, query) {
      query = (0, _utils.trimSpacesEnd)(query) + this.show(token) + ' ';

      if (this.inlineBlock.isActive()) {
        return query;
      } else if (_token.isToken.LIMIT(this.getPreviousReservedToken())) {
        return query;
      } else if (this.currentNewline) {
        return this.addNewline(query);
      } else {
        return query;
      }
    }
    /** Simple append of token onto query */

  }, {
    key: "formatWithoutSpaces",
    value: function formatWithoutSpaces(token, query) {
      return (0, _utils.trimSpacesEnd)(query) + this.show(token);
    }
    /**
     * Add token onto query with spaces - either before, after, or both
     */

  }, {
    key: "formatWithSpaces",
    value: function formatWithSpaces(token, query) {
      var addSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'both';
      var before = addSpace === 'after' ? (0, _utils.trimSpacesEnd)(query) : query;
      var after = addSpace === 'before' ? '' : ' ';
      return before + this.show(token) + after;
    }
  }, {
    key: "formatQuerySeparator",
    value: function formatQuerySeparator(token, query) {
      this.indentation.resetIndentation();
      return [(0, _utils.trimSpacesEnd)(query), this.cfg.newlineBeforeSemicolon ? '\n' : '', this.show(token), '\n'.repeat(this.cfg.linesBetweenQueries + 1)].join('');
    }
    /** Converts token to string, uppercasing if enabled */

  }, {
    key: "show",
    value: function show(token) {
      if ((0, _token.isReserved)(token) || token.type === _token.TokenType.BLOCK_START || token.type === _token.TokenType.BLOCK_END) {
        switch (this.cfg.keywordCase) {
          case 'preserve':
            return token.value;

          case 'upper':
            return token.value.toUpperCase();

          case 'lower':
            return token.value.toLowerCase();
        }
      } else {
        return token.value;
      }
    }
    /** Inserts a newline onto the query */

  }, {
    key: "addNewline",
    value: function addNewline(query) {
      query = (0, _utils.trimSpacesEnd)(query);

      if (!query.endsWith('\n')) {
        query += '\n';
      }

      return query + this.indentation.getIndent();
    }
  }, {
    key: "isTabularStyle",
    value: function isTabularStyle() {
      return this.cfg.indentStyle === 'tabularLeft' || this.cfg.indentStyle === 'tabularRight';
    }
    /** Returns the latest encountered reserved keyword token */

  }, {
    key: "getPreviousReservedToken",
    value: function getPreviousReservedToken() {
      return this.previousReservedToken;
    }
    /** True when currently within SELECT command */

  }, {
    key: "isWithinSelect",
    value: function isWithinSelect() {
      return _token.isToken.SELECT(this.previousCommandToken);
    }
    /** Fetches nth previous token from the token stream */

  }, {
    key: "tokenLookBehind",
    value: function tokenLookBehind() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.tokens[this.index - n] || _token.EOF_TOKEN;
    }
    /** Fetches nth next token from the token stream */

  }, {
    key: "tokenLookAhead",
    value: function tokenLookAhead() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.tokens[this.index + n] || _token.EOF_TOKEN;
    }
  }]);

  return Formatter;
}();

exports["default"] = Formatter;
module.exports = exports.default;
//# sourceMappingURL=Formatter.js.map