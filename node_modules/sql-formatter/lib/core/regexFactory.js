"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWordRegex = exports.createStringRegex = exports.createStringPattern = exports.createReservedWordRegex = exports.createPlaceholderRegex = exports.createParenRegex = exports.createOperatorRegex = exports.createLineCommentRegex = void 0;

var _utils = require("../utils");

/**
 * Builds a RegExp containing all operators for a SQL dialect
 * @param {string} monadOperators - concatenated string of all 1-length operators
 * @param {string[]} polyadOperators - list of strings of all >1-length operators
 */
var createOperatorRegex = function createOperatorRegex(monadOperators, polyadOperators) {
  return new RegExp("^(".concat((0, _utils.sortByLengthDesc)(polyadOperators).map(_utils.escapeRegExp).join('|'), "|") + "[".concat(monadOperators.split('').map(_utils.escapeRegExp).join(''), "])"), 'u');
};
/**
 * Builds a RegExp for valid line comments in a SQL dialect
 * @param {string[]} lineCommentTypes - list of character strings that denote line comments
 */


exports.createOperatorRegex = createOperatorRegex;

var createLineCommentRegex = function createLineCommentRegex(lineCommentTypes) {
  return new RegExp("^((?:".concat(lineCommentTypes.map(function (c) {
    return (0, _utils.escapeRegExp)(c);
  }).join('|'), ").*?)(?:\r\n|\r|\n|$)"), 'u');
};
/**
 * Builds a RegExp for all Reserved Keywords in a SQL dialect
 * @param {string[]} reservedKeywords - list of strings of all Reserved Keywords
 * @param {string} specialWordChars - concatenated string of all special chars that can appear in valid identifiers (and not in Reserved Keywords)
 */


exports.createLineCommentRegex = createLineCommentRegex;

var createReservedWordRegex = function createReservedWordRegex(reservedKeywords) {
  var specialWordChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (reservedKeywords.length === 0) {
    return /^\b$/;
  }

  var reservedKeywordsPattern = (0, _utils.sortByLengthDesc)(reservedKeywords).join('|').replace(/ /g, '\\s+');
  return new RegExp("^(".concat(reservedKeywordsPattern, ")(?![").concat((0, _utils.escapeRegExp)(specialWordChars), "]+)\\b"), 'iu');
};
/**
 * Builds a RegExp for valid identifiers in a SQL dialect
 * @param {Object} specialChars
 * @param {string} specialChars.any - concatenated string of chars that can appear anywhere in a valid identifier
 * @param {string} specialChars.prefix - concatenated string of chars that only appear at the beginning of a valid identifier
 * @param {string} specialChars.suffix - concatenated string of chars that only appear at the end of a valid identifier
 */


exports.createReservedWordRegex = createReservedWordRegex;

var createWordRegex = function createWordRegex() {
  var _specialChars$prefix, _specialChars$suffix, _specialChars$any;

  var specialChars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var prefixLookBehind = "[".concat((0, _utils.escapeRegExp)((_specialChars$prefix = specialChars.prefix) !== null && _specialChars$prefix !== void 0 ? _specialChars$prefix : ''), "]*");
  var suffixLookAhead = "[".concat((0, _utils.escapeRegExp)((_specialChars$suffix = specialChars.suffix) !== null && _specialChars$suffix !== void 0 ? _specialChars$suffix : ''), "]*");
  var unicodeWordChar = '\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}';
  var specialWordChars = "".concat((0, _utils.escapeRegExp)((_specialChars$any = specialChars.any) !== null && _specialChars$any !== void 0 ? _specialChars$any : ''));
  var arrayAccessor = '\\[\\d\\]';
  var mapAccessor = "\\[['\"][".concat(unicodeWordChar, "]+['\"]\\]");
  return new RegExp("^((".concat(prefixLookBehind, "([").concat(unicodeWordChar).concat(specialWordChars, "]+)").concat(suffixLookAhead, ")(").concat(arrayAccessor, "|").concat(mapAccessor, ")?)"), 'u');
}; // This enables the following string patterns:
// 1. backtick quoted string using `` to escape
// 2. square bracket quoted string (SQL Server) using ]] to escape
// 3. double quoted string using "" or \" to escape
// 4. single quoted string using '' or \' to escape
// 5. national character quoted string using N'' or N\' to escape
// 6. Unicode single-quoted string using \' to escape
// 7. Unicode double-quoted string using \" to escape
// 8. PostgreSQL dollar-quoted strings


exports.createWordRegex = createWordRegex;
var patterns = {
  '``': '((`[^`]*($|`))+)',
  '{}': '((\\{[^\\}]*($|\\}))+)',
  '[]': '((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)',
  '""': '(("[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+)',
  "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
  "N''": "((N'[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
  "x''": "(([xX]'[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
  "E''": "((E'[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
  "U&''": "((U&'[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
  'U&""': '((U&"[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+)',
  '$$': '((?<tag>\\$\\w*\\$)[\\s\\S]*?(?:\\k<tag>|$))'
};

/**
 * Builds a string pattern for matching string patterns for all given string types
 * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns
 */
var createStringPattern = function createStringPattern(stringTypes) {
  return stringTypes.map(function (t) {
    return patterns[t];
  }).join('|');
};
/**
 * Builds a RegExp for matching string patterns using `createStringPattern`
 * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns
 */


exports.createStringPattern = createStringPattern;

var createStringRegex = function createStringRegex(stringTypes) {
  return new RegExp('^(' + createStringPattern(stringTypes) + ')', 'u');
};
/** Escapes paren characters for RegExp patterns */


exports.createStringRegex = createStringRegex;

var escapeParen = function escapeParen(paren) {
  if (paren.length === 1) {
    // A single punctuation character
    return (0, _utils.escapeRegExp)(paren);
  } else {
    // longer word
    return '\\b' + paren + '\\b';
  }
};
/**
 * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`
 * @param {string[]} parens - list of strings that denote parenthesis patterns
 */


var createParenRegex = function createParenRegex(parens) {
  return new RegExp('^(' + parens.map(escapeParen).join('|') + ')', 'iu');
};
/**
 * Builds a RegExp for placeholder patterns
 * @param {string[]} types - list of strings that denote placeholder types
 * @param {string} pattern - string that denotes placeholder pattern
 */


exports.createParenRegex = createParenRegex;

var createPlaceholderRegex = function createPlaceholderRegex(types, pattern) {
  if ((0, _utils.isEmpty)(types)) {
    return undefined;
  }

  var typesRegex = types.map(_utils.escapeRegExp).join('|');
  return new RegExp("^((?:".concat(typesRegex, ")(?:").concat(pattern, "))"), 'u');
};

exports.createPlaceholderRegex = createPlaceholderRegex;
//# sourceMappingURL=regexFactory.js.map