{"version":3,"sources":["../../src/core/token.ts"],"names":["TokenType","EOF_TOKEN","type","EOF","value","ZWS","ZWS_REGEX","spaces","testToken","compareToken","token","RegExp","test","isToken","AS","RESERVED_KEYWORD","AND","RESERVED_LOGICAL_OPERATOR","BETWEEN","CASE","BLOCK_START","CAST","BY","END","BLOCK_END","FROM","RESERVED_COMMAND","LIMIT","SELECT","SET","TABLE","WINDOW","WITH","isCommand","RESERVED_BINARY_COMMAND","isReserved","RESERVED_DEPENDENT_CLAUSE","RESERVED_JOIN_CONDITION"],"mappings":"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","sourcesContent":["/** Token type enum for all possible Token categories */\nexport enum TokenType {\n  WORD = 'WORD',\n  STRING = 'STRING',\n  RESERVED_KEYWORD = 'RESERVED_KEYWORD',\n  RESERVED_LOGICAL_OPERATOR = 'RESERVED_LOGICAL_OPERATOR',\n  RESERVED_DEPENDENT_CLAUSE = 'RESERVED_DEPENDENT_CLAUSE',\n  RESERVED_BINARY_COMMAND = 'RESERVED_BINARY_COMMAND',\n  RESERVED_COMMAND = 'RESERVED_COMMAND',\n  RESERVED_JOIN_CONDITION = 'RESERVED_JOIN_CONDITION',\n  OPERATOR = 'OPERATOR',\n  BLOCK_START = 'BLOCK_START',\n  BLOCK_END = 'BLOCK_END',\n  LINE_COMMENT = 'LINE_COMMENT',\n  BLOCK_COMMENT = 'BLOCK_COMMENT',\n  NUMBER = 'NUMBER',\n  PLACEHOLDER = 'PLACEHOLDER',\n  EOF = 'EOF',\n}\n\n/** Struct to store the most basic cohesive unit of language grammar */\nexport interface Token {\n  value: string;\n  type: TokenType;\n  key?: string;\n  whitespaceBefore?: string;\n}\n\n/**\n * For use as a \"missing token\"\n * e.g. in lookAhead and lookBehind to avoid dealing with null values\n */\nexport const EOF_TOKEN = { type: TokenType.EOF, value: '«EOF»' };\n\n/** Special Unicode character to serve as a placeholder for tabular formats as \\w whitespace is unavailable */\nexport const ZWS = '​'; // uses zero-width space (&#8203; / U+200B)\nconst ZWS_REGEX = '\\u200b';\nconst spaces = `[${ZWS_REGEX}\\\\s]`;\n\n/** Checks if two tokens are equivalent */\nexport const testToken =\n  (compareToken: Token) =>\n  (token: Token): boolean =>\n    token.type === compareToken.type &&\n    new RegExp(`^${spaces}*${compareToken.value}${spaces}*$`, 'iu').test(token.value);\n\n/** Util object that allows for easy checking of Reserved Keywords */\nexport const isToken = {\n  AS: testToken({ value: 'AS', type: TokenType.RESERVED_KEYWORD }),\n  AND: testToken({ value: 'AND', type: TokenType.RESERVED_LOGICAL_OPERATOR }),\n  BETWEEN: testToken({ value: 'BETWEEN', type: TokenType.RESERVED_KEYWORD }),\n  CASE: testToken({ value: 'CASE', type: TokenType.BLOCK_START }),\n  CAST: testToken({ value: 'CAST', type: TokenType.RESERVED_KEYWORD }),\n  BY: testToken({ value: 'BY', type: TokenType.RESERVED_KEYWORD }),\n  END: testToken({ value: 'END', type: TokenType.BLOCK_END }),\n  FROM: testToken({ value: 'FROM', type: TokenType.RESERVED_COMMAND }),\n  LIMIT: testToken({ value: 'LIMIT', type: TokenType.RESERVED_COMMAND }),\n  SELECT: testToken({ value: 'SELECT', type: TokenType.RESERVED_COMMAND }),\n  SET: testToken({ value: 'SET', type: TokenType.RESERVED_COMMAND }),\n  TABLE: testToken({ value: 'TABLE', type: TokenType.RESERVED_KEYWORD }),\n  WINDOW: testToken({ value: 'WINDOW', type: TokenType.RESERVED_COMMAND }),\n  WITH: testToken({ value: 'WITH', type: TokenType.RESERVED_COMMAND }),\n};\n\n/** Checks if token is a Reserved Command or Reserved Binary Command */\nexport const isCommand = (token: Token): boolean =>\n  token.type === TokenType.RESERVED_COMMAND || token.type === TokenType.RESERVED_BINARY_COMMAND;\n\n/** Checks if token is any Reserved Keyword or Command */\nexport const isReserved = (token: Token): boolean =>\n  token.type === TokenType.RESERVED_KEYWORD ||\n  token.type === TokenType.RESERVED_LOGICAL_OPERATOR ||\n  token.type === TokenType.RESERVED_DEPENDENT_CLAUSE ||\n  token.type === TokenType.RESERVED_JOIN_CONDITION ||\n  token.type === TokenType.RESERVED_COMMAND ||\n  token.type === TokenType.RESERVED_BINARY_COMMAND;\n"],"file":"token.js"}