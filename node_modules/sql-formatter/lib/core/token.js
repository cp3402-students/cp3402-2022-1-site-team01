"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testToken = exports.isToken = exports.isReserved = exports.isCommand = exports.ZWS = exports.TokenType = exports.EOF_TOKEN = void 0;

/** Token type enum for all possible Token categories */
var TokenType;
/** Struct to store the most basic cohesive unit of language grammar */

exports.TokenType = TokenType;

(function (TokenType) {
  TokenType["WORD"] = "WORD";
  TokenType["STRING"] = "STRING";
  TokenType["RESERVED_KEYWORD"] = "RESERVED_KEYWORD";
  TokenType["RESERVED_LOGICAL_OPERATOR"] = "RESERVED_LOGICAL_OPERATOR";
  TokenType["RESERVED_DEPENDENT_CLAUSE"] = "RESERVED_DEPENDENT_CLAUSE";
  TokenType["RESERVED_BINARY_COMMAND"] = "RESERVED_BINARY_COMMAND";
  TokenType["RESERVED_COMMAND"] = "RESERVED_COMMAND";
  TokenType["RESERVED_JOIN_CONDITION"] = "RESERVED_JOIN_CONDITION";
  TokenType["OPERATOR"] = "OPERATOR";
  TokenType["BLOCK_START"] = "BLOCK_START";
  TokenType["BLOCK_END"] = "BLOCK_END";
  TokenType["LINE_COMMENT"] = "LINE_COMMENT";
  TokenType["BLOCK_COMMENT"] = "BLOCK_COMMENT";
  TokenType["NUMBER"] = "NUMBER";
  TokenType["PLACEHOLDER"] = "PLACEHOLDER";
  TokenType["EOF"] = "EOF";
})(TokenType || (exports.TokenType = TokenType = {}));

/**
 * For use as a "missing token"
 * e.g. in lookAhead and lookBehind to avoid dealing with null values
 */
var EOF_TOKEN = {
  type: TokenType.EOF,
  value: '«EOF»'
};
/** Special Unicode character to serve as a placeholder for tabular formats as \w whitespace is unavailable */

exports.EOF_TOKEN = EOF_TOKEN;
var ZWS = '​'; // uses zero-width space (&#8203; / U+200B)

exports.ZWS = ZWS;
var ZWS_REGEX = "\u200B";
var spaces = "[".concat(ZWS_REGEX, "\\s]");
/** Checks if two tokens are equivalent */

var testToken = function testToken(compareToken) {
  return function (token) {
    return token.type === compareToken.type && new RegExp("^".concat(spaces, "*").concat(compareToken.value).concat(spaces, "*$"), 'iu').test(token.value);
  };
};
/** Util object that allows for easy checking of Reserved Keywords */


exports.testToken = testToken;
var isToken = {
  AS: testToken({
    value: 'AS',
    type: TokenType.RESERVED_KEYWORD
  }),
  AND: testToken({
    value: 'AND',
    type: TokenType.RESERVED_LOGICAL_OPERATOR
  }),
  BETWEEN: testToken({
    value: 'BETWEEN',
    type: TokenType.RESERVED_KEYWORD
  }),
  CASE: testToken({
    value: 'CASE',
    type: TokenType.BLOCK_START
  }),
  CAST: testToken({
    value: 'CAST',
    type: TokenType.RESERVED_KEYWORD
  }),
  BY: testToken({
    value: 'BY',
    type: TokenType.RESERVED_KEYWORD
  }),
  END: testToken({
    value: 'END',
    type: TokenType.BLOCK_END
  }),
  FROM: testToken({
    value: 'FROM',
    type: TokenType.RESERVED_COMMAND
  }),
  LIMIT: testToken({
    value: 'LIMIT',
    type: TokenType.RESERVED_COMMAND
  }),
  SELECT: testToken({
    value: 'SELECT',
    type: TokenType.RESERVED_COMMAND
  }),
  SET: testToken({
    value: 'SET',
    type: TokenType.RESERVED_COMMAND
  }),
  TABLE: testToken({
    value: 'TABLE',
    type: TokenType.RESERVED_KEYWORD
  }),
  WINDOW: testToken({
    value: 'WINDOW',
    type: TokenType.RESERVED_COMMAND
  }),
  WITH: testToken({
    value: 'WITH',
    type: TokenType.RESERVED_COMMAND
  })
};
/** Checks if token is a Reserved Command or Reserved Binary Command */

exports.isToken = isToken;

var isCommand = function isCommand(token) {
  return token.type === TokenType.RESERVED_COMMAND || token.type === TokenType.RESERVED_BINARY_COMMAND;
};
/** Checks if token is any Reserved Keyword or Command */


exports.isCommand = isCommand;

var isReserved = function isReserved(token) {
  return token.type === TokenType.RESERVED_KEYWORD || token.type === TokenType.RESERVED_LOGICAL_OPERATOR || token.type === TokenType.RESERVED_DEPENDENT_CLAUSE || token.type === TokenType.RESERVED_JOIN_CONDITION || token.type === TokenType.RESERVED_COMMAND || token.type === TokenType.RESERVED_BINARY_COMMAND;
};

exports.isReserved = isReserved;
//# sourceMappingURL=token.js.map