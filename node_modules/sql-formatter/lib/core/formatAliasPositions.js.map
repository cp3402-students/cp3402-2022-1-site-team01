{"version":3,"sources":["../../src/core/formatAliasPositions.ts"],"names":["formatAliasPositions","query","lines","split","newQuery","i","length","match","aliasLines","push","splitLines","map","line","slugs","precedingText","alias","undefined","as","aliasMaxLength","replace","repeat","join"],"mappings":"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","sourcesContent":["import { maxLength } from '../utils';\n\n/**\n * Handles select alias placement - tabulates if enabled\n */\nexport default function formatAliasPositions(query: string): string {\n  const lines = query.split('\\n');\n\n  let newQuery: string[] = [];\n  for (let i = 0; i < lines.length; i++) {\n    // find SELECT rows with trailing comma, if no comma (only one row) - no-op\n    if (lines[i].match(/^\\s*SELECT/i)) {\n      let aliasLines: string[] = [];\n      if (lines[i].match(/.*,$/)) {\n        aliasLines = [lines[i]]; // add select to aliasLines in case of tabular formats\n      } else {\n        newQuery.push(lines[i]); // add select to new query\n        if (lines[i].match(/^\\s*SELECT\\s+.+(?!,$)/i)) {\n          continue;\n        }\n        aliasLines.push(lines[++i]);\n      }\n\n      // get all lines in SELECT clause\n      while (lines[i++].match(/.*,$/)) {\n        aliasLines.push(lines[i]);\n      }\n\n      const splitLines = aliasLines\n        .map(line => line.split(/(?<=[^\\s]+) (AS )?(?=[^\\s]+,?$)/i)) // break lines into alias with optional AS, and all preceding text\n        .map(slugs => ({\n          precedingText: slugs[0], // always first split\n          alias: slugs.length > 1 ? slugs[slugs.length - 1] : undefined, // always last in split\n          as: slugs.length === 3 ? slugs[1] : undefined, // 2nd if AS is present, else omitted\n        }));\n\n      const aliasMaxLength = maxLength(\n        splitLines.map(({ precedingText }) => precedingText.replace(/\\s*,\\s*$/, '')) // get longest of precedingText, trim trailing comma for non-alias columns\n      );\n      // re-construct line, aligning by inserting space before AS or alias\n      aliasLines = splitLines.map(\n        ({ precedingText, as, alias }) =>\n          precedingText +\n          (alias ? ' '.repeat(aliasMaxLength - precedingText.length + 1) + (as ?? '') + alias : '')\n      );\n      newQuery = [...newQuery, ...aliasLines];\n    }\n    newQuery.push(lines[i]);\n  }\n\n  return newQuery.join('\\n');\n}\n"],"file":"formatAliasPositions.js"}