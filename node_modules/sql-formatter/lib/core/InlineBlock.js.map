{"version":3,"sources":["../../src/core/InlineBlock.ts"],"names":["InlineBlock","expressionWidth","level","tokens","index","isInlineBlock","length","i","token","value","isForbiddenToken","type","TokenType","BLOCK_START","BLOCK_END","RESERVED_COMMAND","RESERVED_LOGICAL_OPERATOR","BLOCK_COMMENT","isToken","CASE"],"mappings":";;;;;;;AAAA;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;IACqBA,W;AAInB,uBAAYC,eAAZ,EAAqC;AAAA;;AAAA;;AAAA;;AACnC,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKD,eAAL,GAAuBA,eAAvB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;;WACE,yBAAgBE,MAAhB,EAAiCC,KAAjC,EAAgD;AAC9C,UAAI,KAAKF,KAAL,KAAe,CAAf,IAAoB,KAAKG,aAAL,CAAmBF,MAAnB,EAA2BC,KAA3B,CAAxB,EAA2D;AACzD,aAAKF,KAAL,GAAa,CAAb;AACD,OAFD,MAEO,IAAI,KAAKA,KAAL,GAAa,CAAjB,EAAoB;AACzB,aAAKA,KAAL;AACD,OAFM,MAEA;AACL,aAAKA,KAAL,GAAa,CAAb;AACD;AACF;AAED;AACF;AACA;AACA;;;;WACE,eAAM;AACJ,WAAKA,KAAL;AACD;AAED;AACF;AACA;;;;WACE,oBAAoB;AAClB,aAAO,KAAKA,KAAL,GAAa,CAApB;AACD;AAED;AACF;AACA;AACA;;;;WACE,uBAAcC,MAAd,EAA+BC,KAA/B,EAAuD;AACrD,UAAIE,MAAM,GAAG,CAAb;AACA,UAAIJ,KAAK,GAAG,CAAZ;;AAEA,WAAK,IAAIK,CAAC,GAAGH,KAAb,EAAoBG,CAAC,GAAGJ,MAAM,CAACG,MAA/B,EAAuCC,CAAC,EAAxC,EAA4C;AAC1C,YAAMC,KAAK,GAAGL,MAAM,CAACI,CAAD,CAApB;AACAD,QAAAA,MAAM,IAAIE,KAAK,CAACC,KAAN,CAAYH,MAAtB;;AAEA,YAAI,KAAKI,gBAAL,CAAsBF,KAAtB,CAAJ,EAAkC;AAChC,iBAAO,KAAP;AACD,SANyC,CAQ1C;;;AACA,YAAIF,MAAM,GAAG,KAAKL,eAAlB,EAAmC;AACjC,iBAAO,KAAP;AACD;;AAED,YAAIO,KAAK,CAACG,IAAN,KAAeC,iBAAUC,WAA7B,EAA0C;AACxCX,UAAAA,KAAK;AACN,SAFD,MAEO,IAAIM,KAAK,CAACG,IAAN,KAAeC,iBAAUE,SAA7B,EAAwC;AAC7CZ,UAAAA,KAAK;;AACL,cAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,mBAAO,IAAP;AACD;AACF;AACF;;AACD,aAAO,KAAP;AACD,K,CAED;AACA;;;;WACA,gCAAyC;AAAA,UAAtBS,IAAsB,QAAtBA,IAAsB;AAAA,UAAhBF,KAAgB,QAAhBA,KAAgB;AACvC,aACEE,IAAI,KAAKC,iBAAUG,gBAAnB,IACAJ,IAAI,KAAKC,iBAAUI,yBADnB,IAEA;AACAL,MAAAA,IAAI,KAAKC,iBAAUK,aAHnB,IAIAR,KAAK,KAAK,GAJV,IAKAS,eAAQC,IAAR,CAAa;AAAER,QAAAA,IAAI,EAAJA,IAAF;AAAQF,QAAAA,KAAK,EAALA;AAAR,OAAb,CANF,CAMgC;AANhC;AAQD","sourcesContent":["import { isToken, Token, TokenType } from './token';\n\n/**\n * Bookkeeper for inline blocks.\n *\n * Inline blocks are parenthesised expressions that are shorter than INLINE_MAX_LENGTH.\n * These blocks are formatted on a single line, unlike longer parenthesised\n * expressions where open-parenthesis causes newline and increase of indentation.\n */\nexport default class InlineBlock {\n  level: number;\n  expressionWidth: number;\n\n  constructor(expressionWidth: number) {\n    this.level = 0;\n    this.expressionWidth = expressionWidth;\n  }\n\n  /**\n   * Begins inline block when lookahead through upcoming tokens determines\n   * that the block would be smaller than INLINE_MAX_LENGTH.\n   * @param  {Token[]} tokens Array of all tokens\n   * @param  {Number} index Current token position\n   */\n  beginIfPossible(tokens: Token[], index: number) {\n    if (this.level === 0 && this.isInlineBlock(tokens, index)) {\n      this.level = 1;\n    } else if (this.level > 0) {\n      this.level++;\n    } else {\n      this.level = 0;\n    }\n  }\n\n  /**\n   * Finishes current inline block.\n   * There might be several nested ones.\n   */\n  end() {\n    this.level--;\n  }\n\n  /**\n   * True when inside an inline block\n   */\n  isActive(): boolean {\n    return this.level > 0;\n  }\n\n  /**\n   * Check if this should be an inline parentheses block\n   * Examples are \"NOW()\", \"COUNT(*)\", \"int(10)\", key(`somecolumn`), DECIMAL(7,2)\n   */\n  isInlineBlock(tokens: Token[], index: number): boolean {\n    let length = 0;\n    let level = 0;\n\n    for (let i = index; i < tokens.length; i++) {\n      const token = tokens[i];\n      length += token.value.length;\n\n      if (this.isForbiddenToken(token)) {\n        return false;\n      }\n\n      // Overran max length\n      if (length > this.expressionWidth) {\n        return false;\n      }\n\n      if (token.type === TokenType.BLOCK_START) {\n        level++;\n      } else if (token.type === TokenType.BLOCK_END) {\n        level--;\n        if (level === 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // Reserved words that cause newlines, comments and semicolons\n  // are not allowed inside inline parentheses block\n  isForbiddenToken({ type, value }: Token) {\n    return (\n      type === TokenType.RESERVED_COMMAND ||\n      type === TokenType.RESERVED_LOGICAL_OPERATOR ||\n      // type === TokenType.LINE_COMMENT ||\n      type === TokenType.BLOCK_COMMENT ||\n      value === ';' ||\n      isToken.CASE({ type, value }) // CASE cannot have inline blocks\n    );\n  }\n}\n"],"file":"InlineBlock.js"}