"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token = require("./token");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/** Decides addition and removal of AS tokens */
var AliasAs = /*#__PURE__*/function () {
  function AliasAs(aliasAs, formatter) {
    _classCallCheck(this, AliasAs);

    this.aliasAs = aliasAs;
    this.formatter = formatter;
  }
  /** True when AS keyword should be added *before* current token */


  _createClass(AliasAs, [{
    key: "shouldAddBefore",
    value: function shouldAddBefore(token) {
      return this.isMissingTableAlias(token) || this.isMissingSelectColumnAlias(token);
    } // if table alias is missing and should be added

  }, {
    key: "isMissingTableAlias",
    value: function isMissingTableAlias(token) {
      return this.aliasAs === 'always' && token.type === _token.TokenType.WORD && this.lookBehind().value === ')';
    } // if select column alias is missing and should be added

  }, {
    key: "isMissingSelectColumnAlias",
    value: function isMissingSelectColumnAlias(token) {
      var prevToken = this.lookBehind();
      var nextToken = this.lookAhead();
      return (this.aliasAs === 'always' || this.aliasAs === 'select') && this.formatter.isWithinSelect() && token.type === _token.TokenType.WORD && (_token.isToken.END(prevToken) || (prevToken.type === _token.TokenType.WORD || prevToken.type === _token.TokenType.NUMBER) && (nextToken.value === ',' || (0, _token.isCommand)(nextToken)));
    }
    /** True when AS keyword should be added *after* current token */

  }, {
    key: "shouldAddAfter",
    value: function shouldAddAfter() {
      return this.isEdgeCaseCTE() || this.isEdgeCaseCreateTable() || this.isMissingTypeCastAs();
    } // checks for CAST(«expression» [AS] type)

  }, {
    key: "isMissingTypeCastAs",
    value: function isMissingTypeCastAs() {
      return this.aliasAs === 'never' && this.formatter.isWithinSelect() && _token.isToken.CAST(this.formatter.getPreviousReservedToken()) && _token.isToken.AS(this.lookAhead()) && (this.lookAhead(2).type === _token.TokenType.WORD || this.lookAhead(2).type === _token.TokenType.RESERVED_KEYWORD) && this.lookAhead(3).value === ')';
    } // checks for WITH `table` [AS] (

  }, {
    key: "isEdgeCaseCTE",
    value: function isEdgeCaseCTE() {
      var nextToken = this.lookAhead();
      return this.aliasAs === 'never' && _token.isToken.WITH(this.lookBehind()) && (nextToken.value === '(' || _token.isToken.AS(nextToken) && this.lookAhead(2).value === '(');
    } // checks for CREATE TABLE `table` [AS] WITH (

  }, {
    key: "isEdgeCaseCreateTable",
    value: function isEdgeCaseCreateTable() {
      var prevToken = this.lookBehind();
      var nextToken = this.lookAhead();
      return this.aliasAs === 'never' && (_token.isToken.TABLE(prevToken) || prevToken.value.endsWith('TABLE')) && (_token.isToken.WITH(nextToken) || _token.isToken.AS(nextToken) && _token.isToken.WITH(this.lookAhead(2)));
    }
    /* True when the current AS token should be discarded */

  }, {
    key: "shouldRemove",
    value: function shouldRemove() {
      return this.aliasAs === 'never' || this.aliasAs === 'select' && this.isRemovableNonSelectAs();
    }
  }, {
    key: "isRemovableNonSelectAs",
    value: function isRemovableNonSelectAs() {
      return this.lookBehind().value === ')' && // ) [AS] alias but not SELECT (a) [AS] alpha
      !this.formatter.isWithinSelect() && this.lookAhead().value !== '(' // skip WITH foo [AS] ( ...
      ;
    }
  }, {
    key: "lookBehind",
    value: function lookBehind(n) {
      return this.formatter.tokenLookBehind(n);
    }
  }, {
    key: "lookAhead",
    value: function lookAhead(n) {
      return this.formatter.tokenLookAhead(n);
    }
  }]);

  return AliasAs;
}();

exports["default"] = AliasAs;
module.exports = exports.default;
//# sourceMappingURL=AliasAs.js.map