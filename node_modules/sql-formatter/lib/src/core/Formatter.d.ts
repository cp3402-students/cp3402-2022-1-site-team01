import { Token } from './token';
import Tokenizer from './Tokenizer';
import { FormatOptions } from '../types';
/** Main formatter class that produces a final output string from list of tokens */
export default class Formatter {
    private cfg;
    private indentation;
    private inlineBlock;
    private aliasAs;
    private params;
    private asTokenFactory;
    private currentNewline;
    private previousReservedToken;
    private previousCommandToken;
    protected tokens: Token[];
    protected index: number;
    constructor(cfg: FormatOptions);
    /**
     * SQL Tokenizer for this formatter, provided by subclasses.
     */
    protected tokenizer(): Tokenizer;
    /**
     * Reprocess and modify a token based on parsed context.
     * Subclasses can override this to modify tokens during formatting.
     * @param {Token} token - The token to modify
     * @return {Token} new token or the original
     */
    protected tokenOverride(token: Token): Token;
    /**
     * Formats an SQL query.
     * @param {string} query - The SQL query string to be formatted
     * @return {string} The formatter query
     */
    format(query: string): string;
    /**
     * Does post-processing on the formatted query.
     */
    private postFormat;
    /**
     * Performs main construction of query from token list, delegates to other methods for formatting based on token criteria
     */
    private getFormattedQueryFromTokens;
    /**
     * Formats word tokens + any potential AS tokens for aliases
     */
    private formatWord;
    /**
     * Checks if a newline should currently be inserted
     */
    private checkNewline;
    private inlineWidth;
    /**
     * Counts comma-separated clauses (doesn't count commas inside blocks)
     * Note: There's always at least one clause.
     */
    private countClauses;
    /** get all tokens between current token and next Reserved Command or query end */
    private tokensUntilNextCommandOrQueryEnd;
    /** Formats a line comment onto query */
    private formatLineComment;
    /** Formats a block comment onto query */
    private formatBlockComment;
    /** Aligns comment to current indentation level */
    private indentComment;
    /**
     * Formats a Reserved Command onto query, increasing indentation level where necessary
     */
    private formatCommand;
    /**
     * Formats a Reserved Binary Command onto query, joining neighbouring tokens
     */
    private formatBinaryCommand;
    /**
     * Formats a Reserved Keyword onto query, skipping AS if disabled
     */
    private formatKeyword;
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     */
    private formatDependentClause;
    private formatJoinCondition;
    /**
     * Formats an Operator onto query, following rules for specific characters
     */
    private formatOperator;
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     */
    private formatLogicalOperator;
    /** Replace any sequence of whitespace characters with single space */
    private equalizeWhitespace;
    /**
     * Formats a Block Start token (left paren/bracket/brace, CASE) onto query, beginning an Inline Block or increasing indentation where necessary
     */
    private formatBlockStart;
    /**
     * Formats a Block End token (right paren/bracket/brace, END) onto query, closing an Inline Block or decreasing indentation where necessary
     */
    private formatBlockEnd;
    /**
     * Formats a Placeholder item onto query, to be replaced with the value of the placeholder
     */
    formatPlaceholder(token: Token, query: string): string;
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     */
    private formatComma;
    /** Simple append of token onto query */
    private formatWithoutSpaces;
    /**
     * Add token onto query with spaces - either before, after, or both
     */
    private formatWithSpaces;
    private formatQuerySeparator;
    /** Converts token to string, uppercasing if enabled */
    private show;
    /** Inserts a newline onto the query */
    private addNewline;
    private isTabularStyle;
    /** Returns the latest encountered reserved keyword token */
    getPreviousReservedToken(): Token;
    /** True when currently within SELECT command */
    isWithinSelect(): boolean;
    /** Fetches nth previous token from the token stream */
    tokenLookBehind(n?: number): Token;
    /** Fetches nth next token from the token stream */
    tokenLookAhead(n?: number): Token;
}
